import { ExtendedSetOptions, GetOptions, MetadataField, SetOptions } from './types';
declare type KeySchema = {
    key: string;
};
declare type KeyValueSchema<T> = KeySchema & {
    value: T;
    createdAt?: number;
    updatedAt?: number;
    expireTime?: string;
};
export declare type GetRequest = KeySchema & {
    options?: GetOptions;
};
export declare type GetResponse<T> = KeyValueSchema<T>;
export declare type SetRequest<T> = Pick<KeyValueSchema<T>, 'key' | 'value'> & {
    options?: ExtendedSetOptions;
};
export declare type SetResponse<T> = KeyValueSchema<T>;
export declare type DeleteRequest = KeySchema;
declare type QueryWhere = {
    condition: 'BEGINS_WITH';
    property: 'key';
    values: Array<unknown>;
};
export declare type QueryRequest = {
    limit?: number;
    after?: string;
    where?: Array<QueryWhere>;
    options?: {
        metadataFields?: Array<MetadataField>;
    };
};
export declare type QueryResponse<T> = {
    data: Array<KeyValueSchema<T>>;
    cursor?: string;
};
export declare type SecretGetRequest = KeySchema & {
    options?: GetOptions;
};
export declare type SecretGetResponse<T> = KeyValueSchema<T>;
export declare type SecretSetRequest<T> = KeyValueSchema<T> & {
    options?: ExtendedSetOptions;
};
export declare type SecretDeleteRequest = KeySchema;
declare type EntityKeySchema = {
    entityName: string;
    key: string;
};
declare type EntityKeyValueSchema<T> = EntityKeySchema & {
    value: T;
    createdAt?: number;
    updatedAt?: number;
    expireTime?: string;
};
export declare type EntityGetRequest = EntityKeySchema & {
    options?: GetOptions;
};
export declare type EntityGetResponse<T> = EntityKeyValueSchema<T>;
export declare type EntitySetRequest<T> = EntityKeyValueSchema<T> & {
    options?: ExtendedSetOptions;
};
export declare type EntityDeleteRequest = EntityKeySchema;
export declare type EntityQueryFilter = {
    condition: 'BEGINS_WITH' | 'BETWEEN' | 'CONTAINS' | 'EQUAL_TO' | 'EXISTS' | 'GREATER_THAN' | 'GREATER_THAN_EQUAL_TO' | 'LESS_THAN' | 'LESS_THAN_EQUAL_TO' | 'NOT_CONTAINS' | 'NOT_EQUAL_TO' | 'NOT_EXISTS';
    property: string;
    values: Array<unknown>;
};
export declare type EntityQueryFilters = {
    or?: Array<EntityQueryFilter>;
    and?: Array<EntityQueryFilter>;
};
export declare type EntityQueryRequest = {
    limit?: number;
    cursor?: string;
    range?: {
        condition: 'BEGINS_WITH' | 'BETWEEN' | 'EQUAL_TO' | 'GREATER_THAN' | 'GREATER_THAN_EQUAL_TO' | 'LESS_THAN' | 'LESS_THAN_EQUAL_TO';
        values: Array<unknown>;
    };
    filters?: EntityQueryFilters;
    sort?: 'ASC' | 'DESC';
    partition?: Array<unknown>;
    entityName: string;
    indexName: string;
    metadataFields?: Array<MetadataField>;
};
export declare type EntityQueryResponse<T> = {
    data: Array<KeyValueSchema<T>>;
    cursor?: string;
};
export declare type TransactionCondition = EntityQueryFilters;
export declare type RequestSet<T> = {
    key: string;
    value: T;
    entityName?: string;
    conditions?: TransactionCondition;
    options?: SetOptions;
};
export declare type RequestDelete = {
    key: string;
    entityName?: string;
    conditions?: TransactionCondition;
};
export declare type RequestCheck = {
    key: string;
    entityName?: string;
    conditions: TransactionCondition;
};
export declare type TransactionRequest<T> = {
    set?: RequestSet<T>[];
    delete?: RequestDelete[];
    check?: RequestCheck[];
};
export declare type BatchSetItem<T> = {
    entityName?: string;
    key: string;
    value: T;
    options?: SetOptions;
};
export declare type BatchSetRequest<T> = Array<BatchSetItem<T>>;
export declare type BatchSetResponse = {
    successfulKeys: BatchItemSuccess[];
    failedKeys: BatchItemError[];
};
export declare type BatchItemSuccess = {
    key: string;
    entityName?: string;
};
export declare type BatchItemError = {
    key: string;
    entityName?: string;
    error: {
        code: string;
        message: string;
    };
};
export {};
//# sourceMappingURL=kvs-api.d.ts.map