"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.StorageApi = void 0;
const types_1 = require("./interfaces/types");
const error_handling_1 = require("./utils/error-handling");
const errors_1 = require("./errors");
var ResponseType;
(function (ResponseType) {
    ResponseType[ResponseType["NONE"] = 0] = "NONE";
    ResponseType[ResponseType["EXPECTED"] = 1] = "EXPECTED";
    ResponseType[ResponseType["OPTIONAL"] = 2] = "OPTIONAL";
})(ResponseType || (ResponseType = {}));
class StorageApi {
    apiClient;
    constructor(apiClient) {
        this.apiClient = apiClient;
    }
    async get(body) {
        const rs = await this.handleKeyNotFound(async () => {
            return this.request('/api/v1/get', body, ResponseType.EXPECTED);
        });
        return this.processGetResponse(rs, body.options);
    }
    async getSecret(body) {
        const rs = await this.handleKeyNotFound(async () => {
            return this.request('/api/v1/secret/get', body, ResponseType.EXPECTED);
        });
        return this.processGetResponse(rs, body.options);
    }
    async getEntity(body) {
        const rs = await this.handleKeyNotFound(async () => {
            return this.request('/api/v1/entity/get', body, ResponseType.EXPECTED);
        });
        return this.processGetResponse(rs, body.options);
    }
    async set(body) {
        const rs = await this.request('/api/v1/set', body, ResponseType.OPTIONAL);
        return rs && (0, types_1.isOverrideAndReturnOptions)(body.options) ? this.processSetResponse(rs, body.options) : undefined;
    }
    async setSecret(body) {
        const rs = await this.request('/api/v1/secret/set', body, ResponseType.OPTIONAL);
        return rs && (0, types_1.isOverrideAndReturnOptions)(body.options) ? this.processSetResponse(rs, body.options) : undefined;
    }
    async setEntity(body) {
        const rs = await this.request('/api/v1/entity/set', body, ResponseType.OPTIONAL);
        return rs && (0, types_1.isOverrideAndReturnOptions)(body.options) ? this.processSetResponse(rs, body.options) : undefined;
    }
    async delete(body) {
        await this.handleKeyNotFound(async () => {
            return this.request('/api/v1/delete', body, ResponseType.NONE);
        });
    }
    async deleteSecret(body) {
        await this.handleKeyNotFound(async () => {
            return this.request('/api/v1/secret/delete', body, ResponseType.NONE);
        });
    }
    async deleteEntity(body) {
        await this.handleKeyNotFound(async () => {
            return this.request('/api/v1/entity/delete', body, ResponseType.NONE);
        });
    }
    async query(body) {
        const rs = await this.request('/api/v1/query', body, ResponseType.EXPECTED);
        return {
            results: rs.data,
            nextCursor: rs.cursor
        };
    }
    async queryEntity(body) {
        const rs = await this.request('/api/v1/entity/query', body, ResponseType.EXPECTED);
        return {
            results: rs.data,
            nextCursor: rs.cursor
        };
    }
    async batchSet(body) {
        const rs = await this.request('/api/v1/batch/set', body, ResponseType.EXPECTED);
        return {
            successfulKeys: rs.successfulKeys,
            failedKeys: rs.failedKeys
        };
    }
    async transact(transactionRequest) {
        await this.request('/api/v1/transaction', transactionRequest, ResponseType.NONE);
    }
    async handleKeyNotFound(fn) {
        try {
            return await fn();
        }
        catch (e) {
            if (e instanceof errors_1.ForgeKvsAPIError && e.code === 'KEY_NOT_FOUND') {
                return undefined;
            }
            throw e;
        }
    }
    async request(path, body, responseType) {
        const requestBody = {
            method: 'POST',
            body: JSON.stringify(body),
            headers: {
                'content-type': 'application/json'
            }
        };
        const response = await this.apiClient(path, requestBody);
        await (0, error_handling_1.checkResponseError)(response);
        if (responseType === ResponseType.NONE) {
            return;
        }
        const responseText = await response.text();
        if (responseType === ResponseType.OPTIONAL && !responseText) {
            return undefined;
        }
        try {
            return JSON.parse(responseText);
        }
        catch (error) {
            throw new errors_1.ForgeKvsError(`Unexpected error. Response was not valid JSON: ${responseText}`);
        }
    }
    processGetResponse(response, options) {
        if (response && options) {
            const maybeCreatedAt = options.metadataFields?.includes(types_1.MetadataField.CREATED_AT)
                ? { createdAt: response.createdAt }
                : {};
            const maybeUpdatedAt = options.metadataFields?.includes(types_1.MetadataField.UPDATED_AT)
                ? { updatedAt: response.updatedAt }
                : {};
            const maybeExpireTime = options.metadataFields?.includes(types_1.MetadataField.EXPIRE_TIME)
                ? { expireTime: response.expireTime }
                : {};
            return {
                key: response.key,
                value: response.value,
                ...maybeCreatedAt,
                ...maybeUpdatedAt,
                ...maybeExpireTime
            };
        }
        return response?.value;
    }
    processSetResponse(response, options) {
        if (!response) {
            return undefined;
        }
        return {
            key: response.key,
            value: response.value,
            ...(options.returnMetadataFields?.includes(types_1.MetadataField.CREATED_AT) && { createdAt: response.createdAt }),
            ...(options.returnMetadataFields?.includes(types_1.MetadataField.UPDATED_AT) && { updatedAt: response.updatedAt }),
            ...(options.returnMetadataFields?.includes(types_1.MetadataField.EXPIRE_TIME) && { expireTime: response.expireTime })
        };
    }
}
exports.StorageApi = StorageApi;
