"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const conditions_1 = require("../conditions");
const entity_query_1 = require("../entity-query");
const errors_1 = require("../errors");
const types_1 = require("../interfaces/types");
const kvs_1 = require("../kvs");
const storage_api_1 = require("../storage-api");
function prepare(response) {
    const apiClient = jest.fn().mockResolvedValueOnce(response);
    const storageApi = new storage_api_1.StorageApi(apiClient);
    const sut = new kvs_1.KvsImpl(storageApi);
    return {
        apiClient,
        storageApi,
        sut
    };
}
describe('KVS', () => {
    const traceId = 'traceId';
    it('should get correctly', async () => {
        const response = new Response(JSON.stringify({ key: 'foo', value: 'bar' }), {
            status: 200,
            headers: { 'x-trace-id': traceId }
        });
        const { sut, apiClient } = prepare(response);
        const rs = await sut.get('foo');
        expect(rs).toEqual('bar');
        expect(apiClient).toHaveBeenCalledWith('/api/v1/get', expect.objectContaining({
            body: JSON.stringify({ key: 'foo' })
        }));
    });
    it('should get with metadata fields correctly for get', async () => {
        const response = new Response(JSON.stringify({
            key: 'foo',
            value: 'bar',
            createdAt: 1718236800,
            updatedAt: 1718236800,
            expireTime: '2025-01-12T13:00:00Z'
        }), {
            status: 200,
            headers: { 'x-trace-id': traceId }
        });
        const { sut, apiClient } = prepare(response);
        const rs = await sut.get('foo', {
            metadataFields: [types_1.MetadataField.CREATED_AT, types_1.MetadataField.UPDATED_AT, types_1.MetadataField.EXPIRE_TIME]
        });
        expect(rs).toEqual({
            key: 'foo',
            value: 'bar',
            createdAt: 1718236800,
            updatedAt: 1718236800,
            expireTime: '2025-01-12T13:00:00Z'
        });
        expect(apiClient).toHaveBeenCalledWith('/api/v1/get', expect.objectContaining({
            body: JSON.stringify({
                key: 'foo',
                options: { metadataFields: [types_1.MetadataField.CREATED_AT, types_1.MetadataField.UPDATED_AT, types_1.MetadataField.EXPIRE_TIME] }
            })
        }));
    });
    it('should get with metadata fields correctly for entity.get', async () => {
        const response = new Response(JSON.stringify({
            key: 'key-foo',
            value: { foo: 'bar' },
            createdAt: 1718236800,
            updatedAt: 1718236800,
            expireTime: '2025-01-12T13:00:00Z'
        }), {
            status: 200,
            headers: { 'x-trace-id': traceId }
        });
        const { sut, apiClient } = prepare(response);
        const rs = await sut.entity('foo').get('key-foo', {
            metadataFields: [types_1.MetadataField.CREATED_AT, types_1.MetadataField.UPDATED_AT, types_1.MetadataField.EXPIRE_TIME]
        });
        expect(rs).toEqual({
            key: 'key-foo',
            value: { foo: 'bar' },
            createdAt: 1718236800,
            updatedAt: 1718236800,
            expireTime: '2025-01-12T13:00:00Z'
        });
        expect(apiClient).toHaveBeenCalledWith('/api/v1/entity/get', expect.objectContaining({
            body: JSON.stringify({
                entityName: 'foo',
                key: 'key-foo',
                options: { metadataFields: [types_1.MetadataField.CREATED_AT, types_1.MetadataField.UPDATED_AT, types_1.MetadataField.EXPIRE_TIME] }
            })
        }));
    });
    it('should return undefined when get receives 404', async () => {
        const response = new Response(JSON.stringify({ code: 'KEY_NOT_FOUND', message: 'Provided key does not exist' }), {
            status: 404,
            headers: { 'x-trace-id': traceId }
        });
        const { sut, apiClient } = prepare(response);
        const rs = await sut.get('foo');
        expect(rs).toBeUndefined();
        expect(apiClient).toHaveBeenCalledWith('/api/v1/get', expect.objectContaining({
            body: JSON.stringify({ key: 'foo' })
        }));
    });
    it('should handle unexpected metadata fields', async () => {
        const response = new Response(JSON.stringify({
            code: 'BAD_REQUEST',
            message: 'Provided request body is invalid'
        }), {
            status: 400,
            statusText: 'Bad Request',
            headers: { 'x-trace-id': traceId }
        });
        const { sut } = prepare(response);
        await expect(sut.get('foo', { metadataFields: ['INVALID_METADATA_FIELD'] })).rejects.toMatchError(new errors_1.ForgeKvsAPIError({ status: 400, statusText: 'Bad Request', traceId }, { code: 'BAD_REQUEST', message: 'Provided request body is invalid' }));
    });
    it('should handle unexpected response', async () => {
        const response = new Response(JSON.stringify({ code: 'INTERNAL_SERVER_ERROR', message: 'An internal server error has occurred' }), {
            status: 500,
            statusText: 'Internal Server Error',
            headers: { 'x-trace-id': traceId }
        });
        const { sut } = prepare(response);
        await expect(sut.get('foo')).rejects.toMatchError(new errors_1.ForgeKvsAPIError({ status: 500, statusText: 'Internal Server Error', traceId }, { code: 'INTERNAL_SERVER_ERROR', message: 'An internal server error has occurred' }));
    });
    it('should handle non-json response even though status is ok', async () => {
        const response = new Response('Some non JSON response that will fail to parse', {
            status: 200,
            headers: { 'x-trace-id': traceId }
        });
        const { sut } = prepare(response);
        await expect(sut.get('foo')).rejects.toMatchError(new errors_1.ForgeKvsError('Unexpected error. Response was not valid JSON: Some non JSON response that will fail to parse'));
    });
    it('should getSecret correctly', async () => {
        const response = new Response(JSON.stringify({ key: 'foo', value: 'bar' }), {
            status: 200,
            headers: { 'x-trace-id': traceId }
        });
        const { sut, apiClient } = prepare(response);
        const rs = await sut.getSecret('foo');
        expect(rs).toEqual('bar');
        expect(apiClient).toHaveBeenCalledWith('/api/v1/secret/get', expect.objectContaining({
            body: JSON.stringify({ key: 'foo' })
        }));
    });
    it('should getSecret with metadata fields correctly', async () => {
        const response = new Response(JSON.stringify({
            key: 'foo',
            value: 'bar',
            createdAt: 1718236800,
            updatedAt: 1718236800,
            expireTime: '2025-01-12T13:00:00Z'
        }), {
            status: 200,
            headers: { 'x-trace-id': traceId }
        });
        const { sut, apiClient } = prepare(response);
        const rs = await sut.getSecret('foo', {
            metadataFields: [types_1.MetadataField.CREATED_AT, types_1.MetadataField.UPDATED_AT, types_1.MetadataField.EXPIRE_TIME]
        });
        expect(rs).toEqual({
            key: 'foo',
            value: 'bar',
            createdAt: 1718236800,
            updatedAt: 1718236800,
            expireTime: '2025-01-12T13:00:00Z'
        });
        expect(apiClient).toHaveBeenCalledWith('/api/v1/secret/get', expect.objectContaining({
            body: JSON.stringify({
                key: 'foo',
                options: { metadataFields: [types_1.MetadataField.CREATED_AT, types_1.MetadataField.UPDATED_AT, types_1.MetadataField.EXPIRE_TIME] }
            })
        }));
    });
    it('should return undefined when getSecret receives 404', async () => {
        const response = new Response(JSON.stringify({ code: 'KEY_NOT_FOUND', message: 'Provided key does not exist' }), {
            status: 404,
            headers: { 'x-trace-id': traceId }
        });
        const { sut, apiClient } = prepare(response);
        const rs = await sut.getSecret('foo');
        expect(rs).toBeUndefined();
        expect(apiClient).toHaveBeenCalledWith('/api/v1/secret/get', expect.objectContaining({
            body: JSON.stringify({ key: 'foo' })
        }));
    });
    it('should getEntity correctly', async () => {
        const response = new Response(JSON.stringify({ key: 'foo', value: { name: 'Jane Doe' } }), {
            status: 200,
            headers: { 'x-trace-id': traceId }
        });
        const { sut, apiClient } = prepare(response);
        const rs = await sut.entity('employees').get('foo');
        expect(rs).toEqual({ name: 'Jane Doe' });
        expect(apiClient).toHaveBeenCalledWith('/api/v1/entity/get', expect.objectContaining({
            body: JSON.stringify({ entityName: 'employees', key: 'foo' })
        }));
    });
    it('should getEntity with metadata fields correctly', async () => {
        const response = new Response(JSON.stringify({
            key: 'foo',
            value: { name: 'Jane Doe' },
            createdAt: 1718236800,
            updatedAt: 1718236800,
            expireTime: '2025-01-12T13:00:00Z'
        }), {
            status: 200,
            headers: { 'x-trace-id': traceId }
        });
        const { sut, apiClient } = prepare(response);
        const rs = await sut
            .entity('employees')
            .get('foo', { metadataFields: [types_1.MetadataField.CREATED_AT, types_1.MetadataField.UPDATED_AT, types_1.MetadataField.EXPIRE_TIME] });
        expect(rs).toEqual({
            key: 'foo',
            value: { name: 'Jane Doe' },
            createdAt: 1718236800,
            updatedAt: 1718236800,
            expireTime: '2025-01-12T13:00:00Z'
        });
        expect(apiClient).toHaveBeenCalledWith('/api/v1/entity/get', expect.objectContaining({
            body: JSON.stringify({
                entityName: 'employees',
                key: 'foo',
                options: { metadataFields: [types_1.MetadataField.CREATED_AT, types_1.MetadataField.UPDATED_AT, types_1.MetadataField.EXPIRE_TIME] }
            })
        }));
    });
    it('should return undefined when getEntity receives 404', async () => {
        const response = new Response(JSON.stringify({ code: 'KEY_NOT_FOUND', message: 'Provided key does not exist' }), {
            status: 404,
            headers: { 'x-trace-id': traceId }
        });
        const { sut, apiClient } = prepare(response);
        const rs = await sut.entity('employees').get('foo');
        expect(rs).toBeUndefined();
        expect(apiClient).toHaveBeenCalledWith('/api/v1/entity/get', expect.objectContaining({
            body: JSON.stringify({ entityName: 'employees', key: 'foo' })
        }));
    });
    it('should set correctly', async () => {
        const response = new Response(undefined, {
            status: 204,
            headers: { 'x-trace-id': traceId }
        });
        const { sut, apiClient } = prepare(response);
        const rs = await sut.set('foo', 'bar');
        expect(rs).toBeUndefined();
        expect(apiClient).toHaveBeenCalledWith('/api/v1/set', expect.objectContaining({
            body: JSON.stringify({ key: 'foo', value: 'bar' })
        }));
    });
    it('should set correctly with TTL', async () => {
        const response = new Response(undefined, {
            status: 204,
            headers: { 'x-trace-id': traceId }
        });
        const { sut, apiClient } = prepare(response);
        const rs = await sut.set('foo', 'bar', { ttl: { value: 5, unit: 'MINUTES' } });
        expect(rs).toBeUndefined();
        expect(apiClient).toHaveBeenCalledWith('/api/v1/set', expect.objectContaining({
            body: JSON.stringify({ key: 'foo', value: 'bar', options: { ttl: { value: 5, unit: 'MINUTES' } } })
        }));
    });
    it('should set correctly with keyPolicy "FAIL_IF_EXISTS"', async () => {
        const response = new Response(undefined, {
            status: 204,
            headers: { 'x-trace-id': traceId }
        });
        const { sut, apiClient } = prepare(response);
        const rs = await sut.set('foo', 'bar', { ttl: { value: 5, unit: 'MINUTES' }, keyPolicy: 'FAIL_IF_EXISTS' });
        expect(rs).toBeUndefined();
        expect(apiClient).toHaveBeenCalledWith('/api/v1/set', expect.objectContaining({
            body: JSON.stringify({
                key: 'foo',
                value: 'bar',
                options: { ttl: { value: 5, unit: 'MINUTES' }, keyPolicy: 'FAIL_IF_EXISTS' }
            })
        }));
    });
    it('should set correctly with keyPolicy "OVERRIDE" and return value', async () => {
        const responseBody = {
            key: 'foo',
            value: 'bar',
            createdAt: Date.now(),
            updatedAt: Date.now(),
            expireTime: '2025-01-12T13:00:00Z'
        };
        const response = new Response(JSON.stringify(responseBody), {
            status: 200,
            headers: { 'x-trace-id': traceId }
        });
        const { sut, apiClient } = prepare(response);
        const rs = await sut.set('foo', 'bar', {
            ttl: { value: 5, unit: 'MINUTES' },
            keyPolicy: 'OVERRIDE',
            returnValue: 'LATEST',
            returnMetadataFields: [types_1.MetadataField.CREATED_AT, types_1.MetadataField.UPDATED_AT, types_1.MetadataField.EXPIRE_TIME]
        });
        expect(rs).toEqual(responseBody);
        expect(apiClient).toHaveBeenCalledWith('/api/v1/set', expect.objectContaining({
            body: JSON.stringify({
                key: 'foo',
                value: 'bar',
                options: {
                    ttl: { value: 5, unit: 'MINUTES' },
                    keyPolicy: 'OVERRIDE',
                    returnValue: 'LATEST',
                    returnMetadataFields: [types_1.MetadataField.CREATED_AT, types_1.MetadataField.UPDATED_AT, types_1.MetadataField.EXPIRE_TIME]
                }
            })
        }));
    });
    it('should set and return undefined when no previous value exists', async () => {
        const response = new Response(undefined, {
            status: 204,
            headers: { 'x-trace-id': traceId }
        });
        const { sut, apiClient } = prepare(response);
        const rs = await sut.set('foo', 'bar', {
            ttl: { value: 5, unit: 'MINUTES' },
            keyPolicy: 'OVERRIDE',
            returnValue: 'PREVIOUS',
            returnMetadataFields: [types_1.MetadataField.CREATED_AT, types_1.MetadataField.UPDATED_AT, types_1.MetadataField.EXPIRE_TIME]
        });
        expect(rs).toEqual(undefined);
        expect(apiClient).toHaveBeenCalledWith('/api/v1/set', expect.objectContaining({
            body: JSON.stringify({
                key: 'foo',
                value: 'bar',
                options: {
                    ttl: { value: 5, unit: 'MINUTES' },
                    keyPolicy: 'OVERRIDE',
                    returnValue: 'PREVIOUS',
                    returnMetadataFields: [types_1.MetadataField.CREATED_AT, types_1.MetadataField.UPDATED_AT, types_1.MetadataField.EXPIRE_TIME]
                }
            })
        }));
    });
    it('should setSecret correctly', async () => {
        const response = new Response(undefined, {
            status: 204,
            headers: { 'x-trace-id': traceId }
        });
        const { sut, apiClient } = prepare(response);
        const rs = await sut.setSecret('foo', 'bar');
        expect(rs).toBeUndefined();
        expect(apiClient).toHaveBeenCalledWith('/api/v1/secret/set', expect.objectContaining({
            body: JSON.stringify({ key: 'foo', value: 'bar' })
        }));
    });
    it('should setSecret correctly with TTL', async () => {
        const response = new Response(undefined, {
            status: 204,
            headers: { 'x-trace-id': traceId }
        });
        const { sut, apiClient } = prepare(response);
        const rs = await sut.setSecret('foo', 'bar', { ttl: { value: 5, unit: 'MINUTES' } });
        expect(rs).toBeUndefined();
        expect(apiClient).toHaveBeenCalledWith('/api/v1/secret/set', expect.objectContaining({
            body: JSON.stringify({ key: 'foo', value: 'bar', options: { ttl: { value: 5, unit: 'MINUTES' } } })
        }));
    });
    it('should setSecret correctly with keyPolicy "FAIL_IF_EXISTS"', async () => {
        const response = new Response(undefined, {
            status: 204,
            headers: { 'x-trace-id': traceId }
        });
        const { sut, apiClient } = prepare(response);
        const rs = await sut.setSecret('foo', 'bar', { ttl: { value: 5, unit: 'MINUTES' }, keyPolicy: 'FAIL_IF_EXISTS' });
        expect(rs).toBeUndefined();
        expect(apiClient).toHaveBeenCalledWith('/api/v1/secret/set', expect.objectContaining({
            body: JSON.stringify({
                key: 'foo',
                value: 'bar',
                options: { ttl: { value: 5, unit: 'MINUTES' }, keyPolicy: 'FAIL_IF_EXISTS' }
            })
        }));
    });
    it('should setSecret correctly with keyPolicy "OVERRIDE" and return value', async () => {
        const responseBody = {
            key: 'foo',
            value: 'bar',
            createdAt: Date.now(),
            updatedAt: Date.now(),
            expireTime: '2025-01-12T13:00:00Z'
        };
        const response = new Response(JSON.stringify(responseBody), {
            status: 200,
            headers: { 'x-trace-id': traceId }
        });
        const { sut, apiClient } = prepare(response);
        const rs = await sut.setSecret('foo', 'bar', {
            ttl: { value: 5, unit: 'MINUTES' },
            keyPolicy: 'OVERRIDE',
            returnValue: 'LATEST',
            returnMetadataFields: [types_1.MetadataField.CREATED_AT, types_1.MetadataField.UPDATED_AT, types_1.MetadataField.EXPIRE_TIME]
        });
        expect(rs).toEqual(responseBody);
        expect(apiClient).toHaveBeenCalledWith('/api/v1/secret/set', expect.objectContaining({
            body: JSON.stringify({
                key: 'foo',
                value: 'bar',
                options: {
                    ttl: { value: 5, unit: 'MINUTES' },
                    keyPolicy: 'OVERRIDE',
                    returnValue: 'LATEST',
                    returnMetadataFields: [types_1.MetadataField.CREATED_AT, types_1.MetadataField.UPDATED_AT, types_1.MetadataField.EXPIRE_TIME]
                }
            })
        }));
    });
    it('should setSecret and return undefined when no previous value exists', async () => {
        const response = new Response(undefined, {
            status: 204,
            headers: { 'x-trace-id': traceId }
        });
        const { sut, apiClient } = prepare(response);
        const rs = await sut.setSecret('foo', 'bar', {
            ttl: { value: 5, unit: 'MINUTES' },
            keyPolicy: 'OVERRIDE',
            returnValue: 'PREVIOUS',
            returnMetadataFields: [types_1.MetadataField.CREATED_AT, types_1.MetadataField.UPDATED_AT, types_1.MetadataField.EXPIRE_TIME]
        });
        expect(rs).toEqual(undefined);
        expect(apiClient).toHaveBeenCalledWith('/api/v1/secret/set', expect.objectContaining({
            body: JSON.stringify({
                key: 'foo',
                value: 'bar',
                options: {
                    ttl: { value: 5, unit: 'MINUTES' },
                    keyPolicy: 'OVERRIDE',
                    returnValue: 'PREVIOUS',
                    returnMetadataFields: [types_1.MetadataField.CREATED_AT, types_1.MetadataField.UPDATED_AT, types_1.MetadataField.EXPIRE_TIME]
                }
            })
        }));
    });
    it('should setEntity correctly', async () => {
        const response = new Response(undefined, {
            status: 204,
            headers: { 'x-trace-id': traceId }
        });
        const { sut, apiClient } = prepare(response);
        const rs = await sut.entity('employees').set('foo', { name: 'Jane Doe' });
        expect(rs).toBeUndefined();
        expect(apiClient).toHaveBeenCalledWith('/api/v1/entity/set', expect.objectContaining({
            body: JSON.stringify({ entityName: 'employees', key: 'foo', value: { name: 'Jane Doe' } })
        }));
    });
    it('should setEntity correctly with TTL', async () => {
        const response = new Response(undefined, {
            status: 204,
            headers: { 'x-trace-id': traceId }
        });
        const { sut, apiClient } = prepare(response);
        const rs = await sut.entity('employees').set('foo', { name: 'Jane Doe' }, { ttl: { value: 5, unit: 'MINUTES' } });
        expect(rs).toBeUndefined();
        expect(apiClient).toHaveBeenCalledWith('/api/v1/entity/set', expect.objectContaining({
            body: JSON.stringify({
                entityName: 'employees',
                key: 'foo',
                value: { name: 'Jane Doe' },
                options: { ttl: { value: 5, unit: 'MINUTES' } }
            })
        }));
    });
    it('should setEntity correctly with "FAIL_IF_EXISTS"', async () => {
        const response = new Response(undefined, {
            status: 204,
            headers: { 'x-trace-id': traceId }
        });
        const { sut, apiClient } = prepare(response);
        const rs = await sut
            .entity('employees')
            .set('foo', { name: 'Jane Doe' }, { ttl: { value: 5, unit: 'MINUTES' }, keyPolicy: 'FAIL_IF_EXISTS' });
        expect(rs).toBeUndefined();
        expect(apiClient).toHaveBeenCalledWith('/api/v1/entity/set', expect.objectContaining({
            body: JSON.stringify({
                entityName: 'employees',
                key: 'foo',
                value: { name: 'Jane Doe' },
                options: { ttl: { value: 5, unit: 'MINUTES' }, keyPolicy: 'FAIL_IF_EXISTS' }
            })
        }));
    });
    it('should setEntity correctly with "OVERRIDE" and return value', async () => {
        const responseBody = {
            key: 'foo',
            value: 'bar',
            createdAt: Date.now(),
            updatedAt: Date.now(),
            expireTime: '2025-01-12T13:00:00Z'
        };
        const response = new Response(JSON.stringify(responseBody), {
            status: 200,
            headers: { 'x-trace-id': traceId }
        });
        const { sut, apiClient } = prepare(response);
        const rs = await sut.entity('employees').set('foo', { name: 'Jane Doe' }, {
            ttl: { value: 5, unit: 'MINUTES' },
            keyPolicy: 'OVERRIDE',
            returnValue: 'LATEST',
            returnMetadataFields: [types_1.MetadataField.CREATED_AT, types_1.MetadataField.UPDATED_AT, types_1.MetadataField.EXPIRE_TIME]
        });
        expect(rs).toEqual(responseBody);
        expect(apiClient).toHaveBeenCalledWith('/api/v1/entity/set', expect.objectContaining({
            body: JSON.stringify({
                entityName: 'employees',
                key: 'foo',
                value: { name: 'Jane Doe' },
                options: {
                    ttl: { value: 5, unit: 'MINUTES' },
                    keyPolicy: 'OVERRIDE',
                    returnValue: 'LATEST',
                    returnMetadataFields: [types_1.MetadataField.CREATED_AT, types_1.MetadataField.UPDATED_AT, types_1.MetadataField.EXPIRE_TIME]
                }
            })
        }));
    });
    it('should setEntity and return undefined when no previous value exists', async () => {
        const response = new Response(undefined, {
            status: 204,
            headers: { 'x-trace-id': traceId }
        });
        const { sut, apiClient } = prepare(response);
        const rs = await sut.entity('employees').set('foo', { name: 'Jane Doe' }, {
            ttl: { value: 5, unit: 'MINUTES' },
            keyPolicy: 'OVERRIDE',
            returnValue: 'PREVIOUS',
            returnMetadataFields: [types_1.MetadataField.CREATED_AT, types_1.MetadataField.UPDATED_AT, types_1.MetadataField.EXPIRE_TIME]
        });
        expect(rs).toBeUndefined();
        expect(apiClient).toHaveBeenCalledWith('/api/v1/entity/set', expect.objectContaining({
            body: JSON.stringify({
                entityName: 'employees',
                key: 'foo',
                value: { name: 'Jane Doe' },
                options: {
                    ttl: { value: 5, unit: 'MINUTES' },
                    keyPolicy: 'OVERRIDE',
                    returnValue: 'PREVIOUS',
                    returnMetadataFields: [types_1.MetadataField.CREATED_AT, types_1.MetadataField.UPDATED_AT, types_1.MetadataField.EXPIRE_TIME]
                }
            })
        }));
    });
    it('should delete correctly', async () => {
        const response = new Response(undefined, {
            status: 204,
            headers: { 'x-trace-id': traceId }
        });
        const { sut, apiClient } = prepare(response);
        const rs = await sut.delete('foo');
        expect(rs).toBeUndefined();
        expect(apiClient).toHaveBeenCalledWith('/api/v1/delete', expect.objectContaining({
            body: JSON.stringify({ key: 'foo' })
        }));
    });
    it('should return undefined when delete receives 404', async () => {
        const response = new Response(JSON.stringify({ code: 'KEY_NOT_FOUND', message: 'Provided key does not exist' }), {
            status: 404,
            headers: { 'x-trace-id': traceId }
        });
        const { sut, apiClient } = prepare(response);
        const rs = await sut.delete('foo');
        expect(rs).toBeUndefined();
        expect(apiClient).toHaveBeenCalledWith('/api/v1/delete', expect.objectContaining({
            body: JSON.stringify({ key: 'foo' })
        }));
    });
    it('should deleteSecret correctly', async () => {
        const response = new Response(undefined, {
            status: 204,
            headers: { 'x-trace-id': traceId }
        });
        const { sut, apiClient } = prepare(response);
        const rs = await sut.deleteSecret('foo');
        expect(rs).toBeUndefined();
        expect(apiClient).toHaveBeenCalledWith('/api/v1/secret/delete', expect.objectContaining({
            body: JSON.stringify({ key: 'foo' })
        }));
    });
    it('should return undefined when deleteSecret receives 404', async () => {
        const response = new Response(JSON.stringify({ code: 'KEY_NOT_FOUND', message: 'Provided key does not exist' }), {
            status: 404,
            headers: { 'x-trace-id': traceId }
        });
        const { sut, apiClient } = prepare(response);
        const rs = await sut.deleteSecret('foo');
        expect(rs).toBeUndefined();
        expect(apiClient).toHaveBeenCalledWith('/api/v1/secret/delete', expect.objectContaining({
            body: JSON.stringify({ key: 'foo' })
        }));
    });
    it('should deleteEntity correctly', async () => {
        const response = new Response(undefined, {
            status: 204,
            headers: { 'x-trace-id': traceId }
        });
        const { sut, apiClient } = prepare(response);
        const rs = await sut.entity('employees').delete('foo');
        expect(rs).toBeUndefined();
        expect(apiClient).toHaveBeenCalledWith('/api/v1/entity/delete', expect.objectContaining({
            body: JSON.stringify({ entityName: 'employees', key: 'foo' })
        }));
    });
    it('should return undefined when deleteEntity receives 404', async () => {
        const response = new Response(JSON.stringify({ code: 'KEY_NOT_FOUND', message: 'Provided key does not exist' }), {
            status: 404,
            headers: { 'x-trace-id': traceId }
        });
        const { sut, apiClient } = prepare(response);
        const rs = await sut.entity('employees').delete('foo');
        expect(rs).toBeUndefined();
        expect(apiClient).toHaveBeenCalledWith('/api/v1/entity/delete', expect.objectContaining({
            body: JSON.stringify({ entityName: 'employees', key: 'foo' })
        }));
    });
    it('should query correctly', async () => {
        const response = new Response(JSON.stringify({ cursor: 'third-page', data: [{ key: 'foo', value: 'bar' }] }), {
            status: 200,
            headers: { 'x-trace-id': traceId }
        });
        const { sut, apiClient } = prepare(response);
        const rs = await sut
            .query()
            .cursor('second-page')
            .limit(1)
            .where('key', conditions_1.WhereConditions.beginsWith('fo'))
            .getMany();
        expect(rs).toEqual({
            results: [{ key: 'foo', value: 'bar' }],
            nextCursor: 'third-page'
        });
        expect(apiClient).toHaveBeenCalledWith('/api/v1/query', expect.objectContaining({
            body: JSON.stringify({
                limit: 1,
                after: 'second-page',
                where: [{ property: 'key', condition: 'BEGINS_WITH', values: ['fo'] }]
            })
        }));
    });
    it('should query correctly with TTL fields', async () => {
        const response = new Response(JSON.stringify({
            cursor: 'third-page',
            data: [{ key: 'foo', value: 'bar', expireTime: '2025-01-12T13:00:00Z' }]
        }), {
            status: 200,
            headers: { 'x-trace-id': traceId }
        });
        const { sut, apiClient } = prepare(response);
        const rs = await sut
            .query({ metadataFields: [types_1.MetadataField.EXPIRE_TIME] })
            .cursor('second-page')
            .limit(1)
            .where('key', conditions_1.WhereConditions.beginsWith('fo'))
            .getMany();
        expect(rs).toEqual({
            results: [{ key: 'foo', value: 'bar', expireTime: '2025-01-12T13:00:00Z' }],
            nextCursor: 'third-page'
        });
        expect(apiClient).toHaveBeenCalledWith('/api/v1/query', expect.objectContaining({
            body: JSON.stringify({
                limit: 1,
                after: 'second-page',
                where: [{ property: 'key', condition: 'BEGINS_WITH', values: ['fo'] }],
                options: {
                    metadataFields: [types_1.MetadataField.EXPIRE_TIME]
                }
            })
        }));
    });
    it('should getOne out of a list of results', async () => {
        const response = new Response(JSON.stringify({
            data: [
                { key: 'foo', value: 'bar' },
                { key: 'bar', value: 'foo' }
            ]
        }), {
            status: 200,
            headers: { 'x-trace-id': traceId }
        });
        const { sut, apiClient } = prepare(response);
        const rs = await sut.query().getOne();
        expect(rs).toEqual({ key: 'foo', value: 'bar' });
        expect(apiClient).toHaveBeenCalledWith('/api/v1/query', expect.objectContaining({
            body: JSON.stringify({ limit: 1 })
        }));
    });
    it('should default to undefined when getOne receives an empty list', async () => {
        const response = new Response(JSON.stringify({ data: [] }), {
            status: 200,
            headers: { 'x-trace-id': traceId }
        });
        const { sut, apiClient } = prepare(response);
        const rs = await sut.query().getOne();
        expect(rs).toBeUndefined();
        expect(apiClient).toHaveBeenCalledWith('/api/v1/query', expect.objectContaining({
            body: JSON.stringify({ limit: 1 })
        }));
    });
    it('should query entity correctly and pass partition with index and metadata fields', async () => {
        const response = new Response(JSON.stringify({ data: [{ key: 'foo', value: { name: 'Jane Doe' }, expireTime: '2025-01-12T13:00:00Z' }] }), {
            status: 200,
            headers: { 'x-trace-id': traceId }
        });
        const { sut, apiClient } = prepare(response);
        const rs = await sut
            .entity('employees')
            .query({ metadataFields: [types_1.MetadataField.EXPIRE_TIME] })
            .index('by-employmentyear', { partition: [2000] })
            .getMany();
        expect(rs).toEqual({
            results: [{ key: 'foo', value: { name: 'Jane Doe' }, expireTime: '2025-01-12T13:00:00Z' }]
        });
        expect(apiClient).toHaveBeenCalledWith('/api/v1/entity/query', expect.objectContaining({
            body: JSON.stringify({
                entityName: 'employees',
                indexName: 'by-employmentyear',
                partition: [2000],
                options: {
                    metadataFields: [types_1.MetadataField.EXPIRE_TIME]
                }
            })
        }));
    });
    it('should query entity correctly (without any filters)', async () => {
        const response = new Response(JSON.stringify({ data: [{ key: 'foo', value: { name: 'Jane Doe' } }] }), {
            status: 200,
            headers: { 'x-trace-id': traceId }
        });
        const { sut, apiClient } = prepare(response);
        const rs = await sut
            .entity('employees')
            .query()
            .index('by-key')
            .where(conditions_1.WhereConditions.beginsWith('f'))
            .sort(types_1.Sort.ASC)
            .limit(100)
            .cursor('second-page')
            .getMany();
        expect(rs).toEqual({
            results: [{ key: 'foo', value: { name: 'Jane Doe' } }]
        });
        expect(apiClient).toHaveBeenCalledWith('/api/v1/entity/query', expect.objectContaining({
            body: JSON.stringify({
                entityName: 'employees',
                indexName: 'by-key',
                range: { condition: 'BEGINS_WITH', values: ['f'] },
                sort: 'ASC',
                limit: 100,
                cursor: 'second-page'
            })
        }));
    });
    it('should query entity correctly (with "or" filters)', async () => {
        const response = new Response(JSON.stringify({ data: [{ key: 'foo', value: { name: 'Jane Doe' } }] }), {
            status: 200,
            headers: { 'x-trace-id': traceId }
        });
        const { sut, apiClient } = prepare(response);
        const filter = new entity_query_1.FilterBuilder()
            .or('age', conditions_1.FilterConditions.greaterThan(30))
            .or('age', conditions_1.FilterConditions.lessThan(35));
        const rs = await sut
            .entity('employees')
            .query()
            .index('by-key')
            .where(conditions_1.WhereConditions.beginsWith('f'))
            .filters(filter)
            .getMany();
        expect(rs).toEqual({
            results: [{ key: 'foo', value: { name: 'Jane Doe' } }]
        });
        expect(apiClient).toHaveBeenCalledWith('/api/v1/entity/query', expect.objectContaining({
            body: JSON.stringify({
                entityName: 'employees',
                indexName: 'by-key',
                range: { condition: 'BEGINS_WITH', values: ['f'] },
                filters: {
                    or: [
                        { property: 'age', condition: 'GREATER_THAN', values: [30] },
                        { property: 'age', condition: 'LESS_THAN', values: [35] }
                    ]
                }
            })
        }));
    });
    it('should query entity correctly (with "and" filters)', async () => {
        const response = new Response(JSON.stringify({ data: [{ key: 'foo', value: { name: 'Jane Doe' } }] }), {
            status: 200,
            headers: { 'x-trace-id': traceId }
        });
        const { sut, apiClient } = prepare(response);
        const rs = await sut
            .entity('employees')
            .query()
            .index('by-key')
            .where(conditions_1.WhereConditions.beginsWith('f'))
            .filters(new entity_query_1.FilterBuilder()
            .and('age', conditions_1.FilterConditions.greaterThan(30))
            .and('employmentyear', conditions_1.FilterConditions.lessThan(2000)))
            .getMany();
        expect(rs).toEqual({
            results: [{ key: 'foo', value: { name: 'Jane Doe' } }]
        });
        expect(apiClient).toHaveBeenCalledWith('/api/v1/entity/query', expect.objectContaining({
            body: JSON.stringify({
                entityName: 'employees',
                indexName: 'by-key',
                range: { condition: 'BEGINS_WITH', values: ['f'] },
                filters: {
                    and: [
                        { property: 'age', condition: 'GREATER_THAN', values: [30] },
                        { property: 'employmentyear', condition: 'LESS_THAN', values: [2000] }
                    ]
                }
            })
        }));
    });
    it('should getOne entity out of a list', async () => {
        const response = new Response(JSON.stringify({
            data: [
                { key: 'foo', value: { name: 'Jane Foo' } },
                { key: 'bar', value: { name: 'Jane Bar' } }
            ]
        }), {
            status: 200,
            headers: { 'x-trace-id': traceId }
        });
        const { sut, apiClient } = prepare(response);
        const rs = await sut
            .entity('employees')
            .query()
            .index('by-key')
            .where(conditions_1.WhereConditions.beginsWith('f'))
            .getOne();
        expect(rs).toEqual({ key: 'foo', value: { name: 'Jane Foo' } });
        expect(apiClient).toHaveBeenCalledWith('/api/v1/entity/query', expect.objectContaining({
            body: JSON.stringify({
                entityName: 'employees',
                indexName: 'by-key',
                range: { condition: 'BEGINS_WITH', values: ['f'] },
                limit: 1
            })
        }));
    });
    it('should default to undefined when getOne entity receives an empty list', async () => {
        const response = new Response(JSON.stringify({ data: [] }), {
            status: 200,
            headers: { 'x-trace-id': traceId }
        });
        const { sut, apiClient } = prepare(response);
        const rs = await sut
            .entity('employees')
            .query()
            .index('by-key')
            .where(conditions_1.WhereConditions.beginsWith('f'))
            .getOne();
        expect(rs).toBeUndefined();
        expect(apiClient).toHaveBeenCalledWith('/api/v1/entity/query', expect.objectContaining({
            body: JSON.stringify({
                entityName: 'employees',
                indexName: 'by-key',
                range: { condition: 'BEGINS_WITH', values: ['f'] },
                limit: 1
            })
        }));
    });
    it.each([
        {
            title: 'between',
            condition: conditions_1.WhereConditions.between(10, 20),
            expectedPayload: { condition: 'BETWEEN', values: [10, 20] }
        },
        {
            title: 'beginsWith',
            condition: conditions_1.WhereConditions.beginsWith('foo'),
            expectedPayload: { condition: 'BEGINS_WITH', values: ['foo'] }
        },
        {
            title: 'equalTo',
            condition: conditions_1.WhereConditions.equalTo('foo'),
            expectedPayload: { condition: 'EQUAL_TO', values: ['foo'] }
        },
        {
            title: 'greaterThan',
            condition: conditions_1.WhereConditions.greaterThan(10),
            expectedPayload: { condition: 'GREATER_THAN', values: [10] }
        },
        {
            title: 'greaterThanEqualTo',
            condition: conditions_1.WhereConditions.greaterThanEqualTo(10),
            expectedPayload: { condition: 'GREATER_THAN_EQUAL_TO', values: [10] }
        },
        {
            title: 'lessThan',
            condition: conditions_1.WhereConditions.lessThan(10),
            expectedPayload: { condition: 'LESS_THAN', values: [10] }
        },
        {
            title: 'lessThanEqualTo',
            condition: conditions_1.WhereConditions.lessThanEqualTo(10),
            expectedPayload: { condition: 'LESS_THAN_EQUAL_TO', values: [10] }
        }
    ])('should test $title all where conditions', async ({ condition, expectedPayload }) => {
        const response = new Response(JSON.stringify({ data: [{ key: 'foo', value: { name: 'Jane Doe' } }] }), {
            status: 200,
            headers: { 'x-trace-id': traceId }
        });
        const { sut, apiClient } = prepare(response);
        const rs = await sut.entity('employees').query().index('by-key').where(condition).getMany();
        expect(rs).toEqual({
            results: [{ key: 'foo', value: { name: 'Jane Doe' } }]
        });
        expect(apiClient).toHaveBeenCalledWith('/api/v1/entity/query', expect.objectContaining({
            body: JSON.stringify({
                entityName: 'employees',
                indexName: 'by-key',
                range: expectedPayload
            })
        }));
    });
    it.each([
        {
            title: 'between',
            condition: conditions_1.FilterConditions.between(10, 20),
            expectedPayload: { condition: 'BETWEEN', values: [10, 20] }
        },
        {
            title: 'beginsWith',
            condition: conditions_1.FilterConditions.beginsWith('foo'),
            expectedPayload: { condition: 'BEGINS_WITH', values: ['foo'] }
        },
        { title: 'exists', condition: conditions_1.FilterConditions.exists(), expectedPayload: { condition: 'EXISTS', values: [true] } },
        {
            title: 'notExists',
            condition: conditions_1.FilterConditions.notExists(),
            expectedPayload: { condition: 'NOT_EXISTS', values: [true] }
        },
        {
            title: 'greaterThan',
            condition: conditions_1.FilterConditions.greaterThan(10),
            expectedPayload: { condition: 'GREATER_THAN', values: [10] }
        },
        {
            title: 'greaterThanEqualTo',
            condition: conditions_1.FilterConditions.greaterThanEqualTo(10),
            expectedPayload: { condition: 'GREATER_THAN_EQUAL_TO', values: [10] }
        },
        {
            title: 'lessThan',
            condition: conditions_1.FilterConditions.lessThan(10),
            expectedPayload: { condition: 'LESS_THAN', values: [10] }
        },
        {
            title: 'lessThanEqualTo',
            condition: conditions_1.FilterConditions.lessThanEqualTo(10),
            expectedPayload: { condition: 'LESS_THAN_EQUAL_TO', values: [10] }
        },
        {
            title: 'contains',
            condition: conditions_1.FilterConditions.contains('foo'),
            expectedPayload: { condition: 'CONTAINS', values: ['foo'] }
        },
        {
            title: 'notContains',
            condition: conditions_1.FilterConditions.notContains('foo'),
            expectedPayload: { condition: 'NOT_CONTAINS', values: ['foo'] }
        },
        {
            title: 'equalTo',
            condition: conditions_1.FilterConditions.equalTo('foo'),
            expectedPayload: { condition: 'EQUAL_TO', values: ['foo'] }
        },
        {
            title: 'notEqualTo',
            condition: conditions_1.FilterConditions.notEqualTo('foo'),
            expectedPayload: { condition: 'NOT_EQUAL_TO', values: ['foo'] }
        }
    ])('should test $title all filter conditions', async ({ condition, expectedPayload }) => {
        const response = new Response(JSON.stringify({ data: [{ key: 'foo', value: { name: 'Jane Doe' } }] }), {
            status: 200,
            headers: { 'x-trace-id': traceId }
        });
        const { sut, apiClient } = prepare(response);
        const rs = await sut
            .entity('employees')
            .query()
            .index('by-key')
            .filters(new entity_query_1.FilterBuilder().and('name', condition))
            .getMany();
        expect(rs).toEqual({
            results: [{ key: 'foo', value: { name: 'Jane Doe' } }]
        });
        expect(apiClient).toHaveBeenCalledWith('/api/v1/entity/query', expect.objectContaining({
            body: JSON.stringify({
                entityName: 'employees',
                indexName: 'by-key',
                filters: {
                    and: [{ property: 'name', ...expectedPayload }]
                }
            })
        }));
    });
    it('should sumbit transaction correctly', async () => {
        const response = new Response(undefined, {
            status: 200,
            headers: { 'x-trace-id': traceId }
        });
        const { sut, apiClient } = prepare(response);
        await sut.transact().set('foo', 'bar').delete('bar').execute();
        expect(apiClient).toHaveBeenCalledWith('/api/v1/transaction', expect.objectContaining({
            body: JSON.stringify({
                set: [{ key: 'foo', value: 'bar' }],
                delete: [{ key: 'bar' }]
            })
        }));
    });
    it('should sumbit transaction correctly with TTL', async () => {
        const response = new Response(undefined, {
            status: 200,
            headers: { 'x-trace-id': traceId }
        });
        const { sut, apiClient } = prepare(response);
        await sut
            .transact()
            .set('foo', 'bar', undefined, { ttl: { unit: 'SECONDS', value: 5 } })
            .delete('bar')
            .execute();
        expect(apiClient).toHaveBeenCalledWith('/api/v1/transaction', expect.objectContaining({
            body: JSON.stringify({
                set: [{ key: 'foo', value: 'bar', options: { ttl: { unit: 'SECONDS', value: 5 } } }],
                delete: [{ key: 'bar' }]
            })
        }));
    });
    it('should batchSet correctly with mixed entity and non-entity items', async () => {
        const response = new Response(JSON.stringify({
            successfulKeys: [{ key: 'foo', entityName: 'employees' }, { key: 'bar' }],
            failedKeys: [
                {
                    key: 'baz',
                    entityName: 'departments',
                    error: { code: 'VALIDATION_ERROR', message: 'Invalid value' }
                }
            ]
        }), {
            status: 200,
            headers: { 'x-trace-id': traceId }
        });
        const { sut, apiClient } = prepare(response);
        const items = [
            { key: 'foo', value: 'John Doe', entityName: 'employees' },
            { key: 'bar', value: 'simple value' },
            { key: 'baz', value: 'IT Department', entityName: 'departments' }
        ];
        const rs = await sut.batchSet(items);
        expect(rs).toEqual({
            successfulKeys: [{ key: 'foo', entityName: 'employees' }, { key: 'bar' }],
            failedKeys: [
                {
                    key: 'baz',
                    entityName: 'departments',
                    error: { code: 'VALIDATION_ERROR', message: 'Invalid value' }
                }
            ]
        });
        expect(apiClient).toHaveBeenCalledWith('/api/v1/batch/set', expect.objectContaining({
            body: JSON.stringify(items)
        }));
    });
    it('should batchSet correctly with mixed entity and non-entity items with TTL', async () => {
        const response = new Response(JSON.stringify({
            successfulKeys: [{ key: 'foo', entityName: 'employees' }, { key: 'bar' }, { key: 'xxx' }],
            failedKeys: [
                {
                    key: 'baz',
                    entityName: 'departments',
                    error: { code: 'VALIDATION_ERROR', message: 'Invalid value' }
                }
            ]
        }), {
            status: 200,
            headers: { 'x-trace-id': traceId }
        });
        const { sut, apiClient } = prepare(response);
        const ttl = { value: 10, unit: 'MINUTES' };
        const items = [
            { key: 'foo', value: 'John Doe', entityName: 'employees', options: { ttl } },
            { key: 'bar', value: 'simple value', options: { ttl } },
            { key: 'baz', value: 'IT Department', entityName: 'departments', options: { ttl } },
            { key: 'xxx', value: 'yyy', options: { ttl } }
        ];
        const rs = await sut.batchSet(items);
        expect(rs).toEqual({
            successfulKeys: [{ key: 'foo', entityName: 'employees' }, { key: 'bar' }, { key: 'xxx' }],
            failedKeys: [
                {
                    key: 'baz',
                    entityName: 'departments',
                    error: { code: 'VALIDATION_ERROR', message: 'Invalid value' }
                }
            ]
        });
        expect(apiClient).toHaveBeenCalledWith('/api/v1/batch/set', expect.objectContaining({
            body: JSON.stringify(items)
        }));
    });
    it('should handle batchSet with all successful keys', async () => {
        const response = new Response(JSON.stringify({
            successfulKeys: [{ key: 'foo' }, { key: 'bar' }],
            failedKeys: []
        }), {
            status: 200,
            headers: { 'x-trace-id': traceId }
        });
        const { sut, apiClient } = prepare(response);
        const items = [
            { key: 'foo', value: 'value1' },
            { key: 'bar', value: 'value2' }
        ];
        const rs = await sut.batchSet(items);
        expect(rs).toEqual({
            successfulKeys: [{ key: 'foo' }, { key: 'bar' }],
            failedKeys: []
        });
        expect(apiClient).toHaveBeenCalledWith('/api/v1/batch/set', expect.objectContaining({
            body: JSON.stringify(items)
        }));
    });
    it('should handle batchSet with all failed keys', async () => {
        const response = new Response(JSON.stringify({
            successfulKeys: [],
            failedKeys: [
                {
                    key: 'foo',
                    error: { code: 'PERMISSION_DENIED', message: 'Access denied' }
                },
                {
                    key: 'bar',
                    entityName: 'employees',
                    error: { code: 'STORAGE_LIMIT_EXCEEDED', message: 'Storage limit exceeded' }
                }
            ]
        }), {
            status: 200,
            headers: { 'x-trace-id': traceId }
        });
        const { sut, apiClient } = prepare(response);
        const items = [
            { key: 'foo', value: 'value1' },
            { key: 'bar', value: 'value2', entityName: 'employees' }
        ];
        const rs = await sut.batchSet(items);
        expect(rs).toEqual({
            successfulKeys: [],
            failedKeys: [
                {
                    key: 'foo',
                    error: { code: 'PERMISSION_DENIED', message: 'Access denied' }
                },
                {
                    key: 'bar',
                    entityName: 'employees',
                    error: { code: 'STORAGE_LIMIT_EXCEEDED', message: 'Storage limit exceeded' }
                }
            ]
        });
        expect(apiClient).toHaveBeenCalledWith('/api/v1/batch/set', expect.objectContaining({
            body: JSON.stringify(items)
        }));
    });
    it('should handle batchSet API error response', async () => {
        const response = new Response(JSON.stringify({ code: 'INTERNAL_SERVER_ERROR', message: 'An internal server error has occurred' }), {
            status: 500,
            statusText: 'Internal Server Error',
            headers: { 'x-trace-id': traceId }
        });
        const { sut } = prepare(response);
        const items = [{ key: 'foo', value: 'bar' }];
        await expect(sut.batchSet(items)).rejects.toMatchError(new errors_1.ForgeKvsAPIError({ status: 500, statusText: 'Internal Server Error', traceId }, { code: 'INTERNAL_SERVER_ERROR', message: 'An internal server error has occurred' }));
    });
});
